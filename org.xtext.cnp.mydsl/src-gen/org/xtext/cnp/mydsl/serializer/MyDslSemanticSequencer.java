/*
 * generated by Xtext 2.9.0.rc1
 */
package org.xtext.cnp.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.cnp.mydsl.myDsl.AbstractType;
import org.xtext.cnp.mydsl.myDsl.ActionStatement;
import org.xtext.cnp.mydsl.myDsl.Activity;
import org.xtext.cnp.mydsl.myDsl.Agent;
import org.xtext.cnp.mydsl.myDsl.AssertStatement;
import org.xtext.cnp.mydsl.myDsl.Attribute;
import org.xtext.cnp.mydsl.myDsl.AttributeValue;
import org.xtext.cnp.mydsl.myDsl.ChangeStateStatement;
import org.xtext.cnp.mydsl.myDsl.ClassAttributes;
import org.xtext.cnp.mydsl.myDsl.Condition;
import org.xtext.cnp.mydsl.myDsl.ContractNetProtocol;
import org.xtext.cnp.mydsl.myDsl.Division;
import org.xtext.cnp.mydsl.myDsl.Factor;
import org.xtext.cnp.mydsl.myDsl.Minus;
import org.xtext.cnp.mydsl.myDsl.Model;
import org.xtext.cnp.mydsl.myDsl.Multiply;
import org.xtext.cnp.mydsl.myDsl.MyDslPackage;
import org.xtext.cnp.mydsl.myDsl.Operator;
import org.xtext.cnp.mydsl.myDsl.OrganizationalModel;
import org.xtext.cnp.mydsl.myDsl.Plus;
import org.xtext.cnp.mydsl.myDsl.RoleBehavior;
import org.xtext.cnp.mydsl.myDsl.State;
import org.xtext.cnp.mydsl.myDsl.Statement;
import org.xtext.cnp.mydsl.myDsl.Task;
import org.xtext.cnp.mydsl.myDsl.TasksModel;
import org.xtext.cnp.mydsl.myDsl.Variable;
import org.xtext.cnp.mydsl.myDsl.VariableDeclaration;
import org.xtext.cnp.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ABSTRACT_TYPE:
				sequence_AbstractType(context, (AbstractType) semanticObject); 
				return; 
			case MyDslPackage.ACTION:
				sequence_Action(context, (org.xtext.cnp.mydsl.myDsl.Action) semanticObject); 
				return; 
			case MyDslPackage.ACTION_STATEMENT:
				sequence_ActionStatement(context, (ActionStatement) semanticObject); 
				return; 
			case MyDslPackage.ACTIVITY:
				sequence_Activity(context, (Activity) semanticObject); 
				return; 
			case MyDslPackage.AGENT:
				sequence_Agent(context, (Agent) semanticObject); 
				return; 
			case MyDslPackage.ASSERT_STATEMENT:
				sequence_AssertStatement(context, (AssertStatement) semanticObject); 
				return; 
			case MyDslPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case MyDslPackage.ATTRIBUTE_VALUE:
				sequence_AttributeValue(context, (AttributeValue) semanticObject); 
				return; 
			case MyDslPackage.CHANGE_STATE_STATEMENT:
				sequence_ChangeStateStatement(context, (ChangeStateStatement) semanticObject); 
				return; 
			case MyDslPackage.CLASS_ATTRIBUTES:
				sequence_ClassAttributes(context, (ClassAttributes) semanticObject); 
				return; 
			case MyDslPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case MyDslPackage.CONTRACT_NET_PROTOCOL:
				sequence_ContractNetProtocol(context, (ContractNetProtocol) semanticObject); 
				return; 
			case MyDslPackage.DIVISION:
				sequence_Term(context, (Division) semanticObject); 
				return; 
			case MyDslPackage.FACTOR:
				sequence_Factor(context, (Factor) semanticObject); 
				return; 
			case MyDslPackage.MINUS:
				sequence_Expression(context, (Minus) semanticObject); 
				return; 
			case MyDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MyDslPackage.MULTIPLY:
				sequence_Term(context, (Multiply) semanticObject); 
				return; 
			case MyDslPackage.OPERATOR:
				sequence_Operator(context, (Operator) semanticObject); 
				return; 
			case MyDslPackage.ORGANIZATIONAL_MODEL:
				sequence_OrganizationalModel(context, (OrganizationalModel) semanticObject); 
				return; 
			case MyDslPackage.PLUS:
				sequence_Expression(context, (Plus) semanticObject); 
				return; 
			case MyDslPackage.ROLE_BEHAVIOR:
				sequence_RoleBehavior(context, (RoleBehavior) semanticObject); 
				return; 
			case MyDslPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case MyDslPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case MyDslPackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			case MyDslPackage.TASKS_MODEL:
				sequence_TasksModel(context, (TasksModel) semanticObject); 
				return; 
			case MyDslPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case MyDslPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AbstractType returns AbstractType
	 *
	 * Constraint:
	 *     (type=Type | (listType?='List' type=Type))
	 */
	protected void sequence_AbstractType(ISerializationContext context, AbstractType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActionStatement returns ActionStatement
	 *
	 * Constraint:
	 *     (action=[Action|ID] inputs+=QualifiedName*)
	 */
	protected void sequence_ActionStatement(ISerializationContext context, ActionStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (name=ID inputs+=Variable? inputs+=Variable*)
	 */
	protected void sequence_Action(ISerializationContext context, org.xtext.cnp.mydsl.myDsl.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Activity returns Activity
	 *
	 * Constraint:
	 *     (declarations+=VariableDeclaration* if=Condition then+=Statement+ (elseif=Activity | else+=Statement+)?)
	 */
	protected void sequence_Activity(ISerializationContext context, Activity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Agent returns Agent
	 *
	 * Constraint:
	 *     (name=ID attributeValues+=AttributeValue*)
	 */
	protected void sequence_Agent(ISerializationContext context, Agent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssertStatement returns AssertStatement
	 *
	 * Constraint:
	 *     (input=QualifiedName value=Expression)
	 */
	protected void sequence_AssertStatement(ISerializationContext context, AssertStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ASSERT_STATEMENT__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ASSERT_STATEMENT__INPUT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ASSERT_STATEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ASSERT_STATEMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssertStatementAccess().getInputQualifiedNameParserRuleCall_0_0(), semanticObject.getInput());
		feeder.accept(grammarAccess.getAssertStatementAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeValue returns AttributeValue
	 *
	 * Constraint:
	 *     (attribute=[Attribute|ID] value=Parameter)
	 */
	protected void sequence_AttributeValue(ISerializationContext context, AttributeValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATTRIBUTE_VALUE__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATTRIBUTE_VALUE__ATTRIBUTE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATTRIBUTE_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATTRIBUTE_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeValueAccess().getAttributeAttributeIDTerminalRuleCall_0_0_1(), semanticObject.getAttribute());
		feeder.accept(grammarAccess.getAttributeValueAccess().getValueParameterParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (type=AbstractType name=ID default=Parameter?)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChangeStateStatement returns ChangeStateStatement
	 *
	 * Constraint:
	 *     targetState=[State|ID]
	 */
	protected void sequence_ChangeStateStatement(ISerializationContext context, ChangeStateStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CHANGE_STATE_STATEMENT__TARGET_STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CHANGE_STATE_STATEMENT__TARGET_STATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChangeStateStatementAccess().getTargetStateStateIDTerminalRuleCall_1_0_1(), semanticObject.getTargetState());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassAttributes returns ClassAttributes
	 *
	 * Constraint:
	 *     agentAttributes+=Attribute+
	 */
	protected void sequence_ClassAttributes(ISerializationContext context, ClassAttributes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (subjective=QualifiedName operator=Operator objective=Expression ((and?='and' | or?='or') compareCondition=Condition)?)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContractNetProtocol returns ContractNetProtocol
	 *
	 * Constraint:
	 *     (name=ID variables+=Variable* roleBehavior+=RoleBehavior*)
	 */
	protected void sequence_ContractNetProtocol(ISerializationContext context, ContractNetProtocol semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     Expression.Plus_1_0_0_0 returns Minus
	 *     Expression.Minus_1_0_1_0 returns Minus
	 *
	 * Constraint:
	 *     (left=Expression_Minus_1_0_1_0 right=Term)
	 */
	protected void sequence_Expression(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getRightTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Plus
	 *     Expression.Plus_1_0_0_0 returns Plus
	 *     Expression.Minus_1_0_1_0 returns Plus
	 *
	 * Constraint:
	 *     (left=Expression_Plus_1_0_0_0 right=Term)
	 */
	protected void sequence_Expression(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getRightTermParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Factor
	 *     Expression.Plus_1_0_0_0 returns Factor
	 *     Expression.Minus_1_0_1_0 returns Factor
	 *     Term returns Factor
	 *     Term.Multiply_1_0_0_0 returns Factor
	 *     Term.Division_1_0_1_0 returns Factor
	 *     Factor returns Factor
	 *
	 * Constraint:
	 *     (number=Number | variable=QualifiedName | string=STRING | boolean=BOOLEAN | expression=Expression)
	 */
	protected void sequence_Factor(ISerializationContext context, Factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         agentAttributes=ClassAttributes 
	 *         taskAttributes=ClassAttributes 
	 *         bidAttributes=ClassAttributes 
	 *         contractAttributes=ClassAttributes 
	 *         organizationalModel=OrganizationalModel 
	 *         tasksModel=TasksModel 
	 *         contractNetProtocols+=ContractNetProtocol*
	 *     )
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operator returns Operator
	 *
	 * Constraint:
	 *     (
	 *         equalTo?='==' | 
	 *         largerThan?='>' | 
	 *         smallerThan?='<' | 
	 *         largerOrEqualTo?='>=' | 
	 *         smallerOrEqualTo?='<=' | 
	 *         notEqualTo?='!='
	 *     )
	 */
	protected void sequence_Operator(ISerializationContext context, Operator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OrganizationalModel returns OrganizationalModel
	 *
	 * Constraint:
	 *     agents+=Agent+
	 */
	protected void sequence_OrganizationalModel(ISerializationContext context, OrganizationalModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RoleBehavior returns RoleBehavior
	 *
	 * Constraint:
	 *     (name=ID actions+=Action* states+=State+ startState=[State|ID] endState=[State|ID])
	 */
	protected void sequence_RoleBehavior(ISerializationContext context, RoleBehavior semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     State returns State
	 *
	 * Constraint:
	 *     ((backgroundState?='backgroundState' name=ID) | (name=ID variables+=Variable* activities+=Activity+))
	 */
	protected void sequence_State(ISerializationContext context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (
	 *         (isAction?='Do' actionStatement=ActionStatement) | 
	 *         (isChangeState?='->' changeStateStatement=ChangeStateStatement) | 
	 *         assertStatement=AssertStatement
	 *     )
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Task returns Task
	 *
	 * Constraint:
	 *     (name=ID attributeValues+=AttributeValue*)
	 */
	protected void sequence_Task(ISerializationContext context, Task semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TasksModel returns TasksModel
	 *
	 * Constraint:
	 *     tasks+=Task+
	 */
	protected void sequence_TasksModel(ISerializationContext context, TasksModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Division
	 *     Expression.Plus_1_0_0_0 returns Division
	 *     Expression.Minus_1_0_1_0 returns Division
	 *     Term returns Division
	 *     Term.Multiply_1_0_0_0 returns Division
	 *     Term.Division_1_0_1_0 returns Division
	 *
	 * Constraint:
	 *     (left=Term_Division_1_0_1_0 right=Factor)
	 */
	protected void sequence_Term(ISerializationContext context, Division semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DIVISION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DIVISION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DIVISION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DIVISION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTermAccess().getDivisionLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTermAccess().getRightFactorParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Multiply
	 *     Expression.Plus_1_0_0_0 returns Multiply
	 *     Expression.Minus_1_0_1_0 returns Multiply
	 *     Term returns Multiply
	 *     Term.Multiply_1_0_0_0 returns Multiply
	 *     Term.Division_1_0_1_0 returns Multiply
	 *
	 * Constraint:
	 *     (left=Term_Multiply_1_0_0_0 right=Factor)
	 */
	protected void sequence_Term(ISerializationContext context, Multiply semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MULTIPLY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MULTIPLY__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MULTIPLY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MULTIPLY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTermAccess().getMultiplyLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTermAccess().getRightFactorParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration_VariableDeclaration_1 value=Expression)
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARIABLE_DECLARATION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARIABLE_DECLARATION__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARIABLE_DECLARATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARIABLE_DECLARATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getVariableDeclarationVariableAction_1(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getValueExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *     VariableDeclaration.VariableDeclaration_1 returns Variable
	 *
	 * Constraint:
	 *     (type=AbstractType name=ID)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARIABLE__TYPE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getTypeAbstractTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
